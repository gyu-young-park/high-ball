# Select Queries

이제 우리의 ORM에 querying feature들을 추가해보도록 하자.

API design은 다음과 같다.

```py
john = Author(name="John Doe", age=23)
vik = Author(name="Vik Star", age=43)
db.save(john)
db.save(vik)

# querying all objects
authors = db.all(Author)

# querying one single object
john_from_db = db.get(Autor, 1) # 1 is the ID
```

## Select All Objects
먼저 unit test를 만들어보도록 하자.

- `test_orm.py`
```py
def test_query_all_authors(db, Author):
    db.create(Author)
    john = Author(name="John Doe", age=23)
    vik = Author(name="Vik Star", age=43)
    db.save(john)
    db.save(vik)
    
    authors = db.all(Author)
    
    assert Author._get_select_all_sql() == (
        "SELECT id, age, name FROM author;",
        ["id", "age", "name"]
    )
    
    assert len(authors) == 2
    assert type(authors[0]) == Author
    assert {a.age for a in authors} == {23, 43}
    assert {a.name for a in authors} == {"John Doe", "Vik Star"}
```

다음의 테스트는 이와 같다.
1. `Author` table을 만들고 새로운 인스턴스들을 추가한다.
2. database class 인스턴스의 `all()` 메서드를 호출한다.
3. 생성된 sql문이 정확한지 확인한다.
4. 반환된 object의 수가 정확한지 확인한다.
5. 반환된 object가 오직 `Author` 클래스에 관한 것인지 확인한다.
5. 반환된 object의 값이 정확한지 확인한다.

여태까지 우리의 `orm.py`를 만든 것들을 보면 일정한 패턴이 존재하는데, 이는 `_get_insert_sql`에서와 같이 sql template 문자열을 만들고 이에 필요한 값을 사용한 다음 `execute`를 실행한다는 것이다. 위 테스트의 `_get_select_all_sql`역시도 이와 같은 패턴으로 작성되는 것이다.

## Implementation
이제 구현을 해보도록 하자. 먼저, `Database` 클래스의 `all` 메서드를 구현하도록 하자. `all`메서드는 `Table`을 상속받은 클래스를 인자로 받아, 관련된 데이터를 모두 `select`해주는 코드를 만들면 된다.

```py
class Database:
    ...
    def all(self, table):
        pass
```

우리가 만들 쿼리문은 다음과 같다.
```sql
SELECT {fields} FROM {name};
```

`{name}`은 `cls.__name__.lower()`를 호출하여 얻을 수 있다. `{fields}`는 table의 맴버들을 순회하면서 list에 `Column`과 `ForeignKey`의 인스턴스인 fields를 추가하면 된다.

이와 같은 기능해주는 `_get_select_all_sql`메서드를 `Table` 클래스에 만들어주도록 하자.

- `orm.py`
```py
class Table:
    ...
    @classmethod
    def _get_select_all_sql(cls):
        SELECT_ALL_SQL = 'SELECT {fields} FROM {name};'
        
        fields = ['id']
        for name, field in inspect.getmembers(cls):
            if isinstance(field, Column):
                fields.append(name)
            if isinstance(field, ForeignKey):
                fields.append(name + "_id")
        
        sql = SELECT_ALL_SQL.format(name=cls.__name__.lower(), fields=", ".join(fields))
        return sql, fields
```
주목해야할 몇가지 점이 있다.

1. 첫번째는 `id`은 모든 `Table`에 있기 때문에 `fields`에 먼저 넣어줬는데, `Table` 클래스의 속성에는 명시적으로 없어서 미리 넣어준 것이다.
2. 두번째는 `ForeignKey`인데, 우리가 데이터베이스에 저장할 때 `_id`로 접미사를 두었기 때문에 `_id`를 붙여줘야 호출이 된다.
3. 또한 두번째 인자인 `fields`를 확인해보도록 하자. 이는 추후에 쓰이는 인자로 나중에 알게된다.

이제 `Database`의 `all` 메서드를 구현해보도록 하자. `get_select_all_sql()`메서드로 반환된 SQL문을 실행하고 반환된 row들을 list로 만들어 반환시켜주어야 한다.

- `orm.py`
```py
class Database:
    ...
    def all(self, table):
        sql, fields = table._get_select_all_sql()
        
        result = []
        for row in self.conn.execute(sql).fetchall():
            instance = table()
            for field, value in zip(fields, row):
                setattr(instance, field, value)
            result.append(instance)
        
        return result
```
`setattr`을 호출하면 주어진 객체의 주어진 attribute에 값을 설정한다. `setattr(author, 'name', 'John Doe')`은 다음과 같다. `author.name = 'John Doe'`

`all`메서드에서 `for`이 동작하는 것은 다음과 같다.
1. sql문을 통해 반환된 row들을 순회한다.
2. `table` class의 객체를 생성한다.
3. `zip()`을 통해서 field와 value의 tuple을 만든다.
4. 다른 `for` 루프에서 `table` 클래스의 attribute를 `setattr`을 통해 설정하도록 한다.
5. list에 생성한 object를 넣어준다.

이제 테스트 코드를 실행해보면 문제없이 성공하는 것을 확인할 수 있다. 다음으로 단일 row를 호출하는 코드를 만들어보도록 하자.

## Select Single Object
위에서 다음과 같이 단일 객체를 호출하도록 하였다.
```py
john_from_db = db.get(Autor, 1) # 1 is the ID
```

`Database` 클래스의 `get` 메서드를 구현해보도록 하자.

- `test_orm.py`
```py
...
def test_get_author(db, Author):
    db.create(Author)
    roman = Author(name="John Doe", age=43)
    db.save(roman)

    john_from_db = db.get(Author, id=1)

    assert Author._get_select_where_sql(id=1) == (
        "SELECT id, age, name FROM author WHERE id = ?;",
        ["id", "age", "name"],
        [1]
    )
    assert type(john_from_db) == Author
    assert john_from_db.age == 43
    assert john_from_db.name == "John Doe"
    assert john_from_db.id == 1
```
위에서 작성한 테스트 코드와 로직은 일맥상통하다. SQL문을 만들고 이를 실행한 결과가 기대한 결과인지를 확인하는 것이다.

## Implementation
`Database` 클래스에 `get` 메서드가 필요할 것이다.

- `orm.py`
```py
...
class Database:
    ...
    def get(self, table, id):
        pass
```
이제 아까 전과 같이 `Table` 클래스에 `classmethod`로 `_get_select_where_sql`을 만들어서 Database 클래스의 `get`에서 호출하도록 하자.

- `orm.py`
```py
...
class Table:
    ...
    @classmethod
    def _get_select_where_sql(cls, id):
        pass
...
```
`_get_select_where_sql`은 `_get_select_all_sql`과 크게 다를바 없다. 오직 한 개의 row를 `select`한다는 점을 빼고는 말이다. 때문에 우리의 sql문은 `where`절이 필요하고 다음의 template를 갖게 된다. `SELECT {fields} FROM {name} WHERE id = ?;` 여기에서 `{fields}`와 `{name}`변수들은 정확히 `_get_select_all_sql()`에서와 같다. 

이제 구현해보도록 하자.

- `orm.py`
```py
class Table:
    ...
    @classmethod
    def _get_select_where_sql(cls, id):
        SELECT_WHERE_SQL = 'SELECT {fields} FROM {name} WHERE id = ?;'
        fields = ["id"]
        for name, field in inspect.getmembers(cls):
            if isinstance(field, Column):
                fields.append(name)
            if isinstance(field, ForeignKey):
                fields.append(name + "_id")
            
        sql = SELECT_WHERE_SQL.format(name=cls.__name__.lower(), fields=", ".join(fields))
        params = [id]
        
        return sql, fields, params
    ...
```
이제 `Database` 클래스의 `get` 메서드를 구현할 차례이다. `get`메서드는 `_get_select_where_sql`를 호출하여 단일 결과만 반환하면 된다.

- `orm.py`
```py
class Database:
    ...
    def get(self, table, id):
        sql, fields, params = table._get_select_where_sql(id=id)
        
        row = self.conn.execute(sql, params).fetchone()
        if row is None:
            raise Exception(f"{table.__name__} instance with id {id} does not exist")
        
        instance = table()
        for field, value in zip(fields, row):
            setattr(instance, field, value)
        
        return instance
    ...
```
이제 하나하나 해보도록 하자.

1. `_get_select_where_sql()`메서드를 호출하여 SQL문, fields, parameter들을 얻도록 하자.
2. `sql` 모듈의 `fetchone()`메서드를 사용하여 파라미터와 함께 `SQL` query를 실행하도록 한다.
3. `SQL` query문을 실행하여 나온 결과가 있는 지 없는 지 확인하도록 한다. 없다면 `exception`을 발생시킨다.
4. `table`인스턴스를 만들고 해당 인스턴스의 field들을 value로 채워준다.
5. 인스턴스를 반환한다.

이제 테스트를 실행시켜보도록 하자. 한 곳에서 에러가 발생할텐데 바로 `id`를 체크하는 부분이다.

```py
assert john_from_db.id == 1
```
우리는 `setattr`로 instance의 `id`를 설정했을 것이다. 왜일까??

그 이유는 `Table` 클래스에서 `id`를 `_data`라는 dictionary로 관리하기 때문이다.

```py
class Table:
    def __init__(self, **kwargs):
        self._data = {
            "id": None
        }
        
        for key, value in kwargs.items():
            self._data[key] = value
    ...
```
`john_from_db.id`로 접근하면 `Table`의 `def __getattribute__(self, key):`가 실행되고, `_data`에 `key`가 있는 지 확인한다.

```py
class Table:
    ...
    def __getattribute__(self, key):
        _data = super().__getattribute__("_data")
        if key in _data:
            return _data[key]
        return super().__getattribute__(key)
    ...
```
`key`가 `id`라면 `__getattribute__`에서 `_data['id']`르 찾으려고할 것이고, `_data`에 `id`가 있으니 `return`을 하게된다. 문제는 `id`가 맨 처음에는 `None`으로 설정된다는 것이다.

우리가 사용한 `setattr(instance, field, value)`로 `field`를 설정하면 `_data`에는 `id`가 설정되지 않는다. 따라서, 우리는 `setattr`를 오버라이드하여 `_data` 딕셔너리에 attribute를 설정하도록 해야한다.

- `orm.py`
```py
class Table:
    ...
    def __setattr__(self, key, value):
        super().__setattr__(key, value)
        if key in self._data:
            self._data[key] = value
    ...
```
다음과 같이 `Table`에 `__setattr__`메서드를 오버라이드해주면 된다. 이제 `self._data` 딕셔너리에서도 `id`를 설정하게 되는 것이다.

다시 테스트 코드를 실행해보면 성공해있을 것이다.

## Foreign Keys
