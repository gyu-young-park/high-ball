# Select Queries
이제 ORM에 쿼리기능을 추가해보도록 하자.

```py
john = Author(name="John Doe", age=23)
vik = Author(name="Vik Star", age=43)
db.save(john)
db.save(vik)

# querying all objects
authors = db.all(Author)

# querying one single object
john_from_db = db.get(Author, 1) # 1 is the ID
```
위의 API를 추가해보도록 하자.

## Select All Objects
먼저 unit test code를 추가해보도록 하자.

- `test_orm.py`
```py
def test_query_all_authors(db, Author):
    db.create(Author)
    john = Author(name="John Doe", age=23)
    vik = Author(name="Vik Star", age=43)
    db.save(john)
    db.save(vik)

    authors = db.all(Author)

    assert Author._get_select_all_sql() == (
        "SELECT id, age, name FROM author;",
        ["id", "age", "name"]
    )

    assert len(authors) == 2
    assert type(authors[0]) == Author
    assert {a.age for a in authors} == {23, 43}
    assert {a.name for a in authors}  == {"John Doe", "Vik Star"}
```
해당 테스트는 다음과 같다.

1. `Author` table을 만들고 새로운 feature들을 추가한다.
2. `Database` class 인스턴스의 `all()` 메서드를 호출한다. 
3. 생성된 SQL문이 정확한지 확인한다.
4. 반환된 object들이 정확한지 확인한다.
5. `Author` 클래스의 객체만 반환되는 지 확인한다.
6. 해당 값이 올바른 지 확인한다.

몇 가지 집중해야할 부분이 있는데, 하나는 SQL문 문자열과 값을 가진 template가 있다는 것이다. `_get_this_sql()`을 호출하면 table 그자체 또는 인스턴스로부터 필요한 값들을 모두 얻을 수 있다. 해당 반환 값은 `execute()` 메서드에 의해 사용되는 값들이다.

## Implementation
먼저 `Database` 클래스의 `all`메서드를 구현해보도록 하자.

- `orm.py`
```py
class Database:
    ...
    def all(self, table):
        pass
```

다음으로 `Table`클래스의 `_get_select_all_sql`메서드를 구현하도록 하자. 위의 테스트 코드에서 보았듯이 생성할 `query sql`문과 `query`할 `fields`값들을 리스트로 반환해준다.

우리가 만들 sql절은 다음과 같다.
```sql
SELECT {fields} FROM {name};
```
`{name}`은 table의 이름이다. `{fields}`는 column 이름들이다. `{name}`은 `cls.__name__.lower()`을 통해 호출할 수 있다. `{fields}`는 table의 맴버변수들 중에 `Column`과 `ForeignKey` 클래스를 가진 값들로 얻을 수 있다.


- `orm.py`
```py
class Table:
    ...   
    @classmethod
    def _get_select_all_sql(cls):
        SELECT_ALL_SQL = "SELECT {fields} FROM {name};"

        fields = ["id"]
        for name, field in inspect.getmembers(cls):
            if isinstance(field, Column):
                fields.append(name)
            if isinstance(field, ForeignKey):
                fields.append(name + "_id")
        
        sql = SELECT_ALL_SQL.format(name=cls.__name__.lower(), fields=", ".join(fields))

        return sql, fields
    ...
```

집중해야할 부분들이 몇가지 있다.

1. `id`가 이미 `fields` 리스트에 있는데, 이는 table마다 `id`가 있지만 명시적으로 클래스에 맴버 변수로 만들어주지 않아서 추가한 것이다.
2. `foreign key`는 `name + _id` 구조이기 때문에 따로 설정하여 `fields`에 추가한 것이다.
3. 두번째 매개변수로 `fields` 이름들을 반환해준다.

다음으로 해줄 것은 `Database`의 `all` 메서드를 구현해줄 차례이다. `get_select_all_sql()` 메서드에 의해 반환된 `SQL`문을 실행할 필요가 있다는 것을 확인하도록 하자. 실행 후 반환된 row들로부터 객체 리스트를 만들고 이를 python 객체에 반영해주어 리턴해주는 것을 생각하도록 하자.

- `orm.py`
```py
class Database:
    ...
    def all(self, table):
        sql, fields = table._get_select_all_sql()

        result = []
        for row in self.conn.execute(sql).fetchall():
            instance = table()
            for field, value in zip(fields, row):
                setattr(instance, field, value)
            result.append(instance)
        return result
```
`zip`과 `setattr`에 집중해보자.

`setattr()`을 통해 attribute 속성을 심어줄 수 있다. 이를 통해서 sql문을 실행하여 결과로 얻은 `row`들을 table 객체에 심해주는 것이다. 즉, `setattr(author, 'name', 'John Doe'`는 `author.name = 'John Doe'`을 호출하는 것과 동일하다. 

`zip`은 iterable 객체를 받아서 tuple로 모아서 `tuple`로 반환해준다. 가령 다음과 같다.

```py
fields = ["name", "age"]
values = ["John Doe", 35]
print(list(zip(field,s value)))
```
이에 대한 결과는 `[("name", "John Doe"), ("age", 35)]`로 나온다.

`all()`메서드를 다시 살펴보면 `for` loop에서 동작하는 것은 다음과 같다.

1. SQL문에 의해 반환된 row들을 순회
2. table class의 인스턴스를 생성
3. `zip()`의 도움을 받아서 `fields`의 이름과 값들을 tuple로 묶어준다.
4. attributes(fields)와 값을 생성한 인스턴스에 할당한다.
5. 결과 list를 채워주고 반환한다.

테스트 코드를 실행하면 성공한다.

```py
pytest ./test_orm.py

```
test_orm.py ......                                                      [100%]

============================== 6 passed in 0.01s ==============================
```

## Select Single Object